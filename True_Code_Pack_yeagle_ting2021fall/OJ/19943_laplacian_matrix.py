# -*- coding: utf-8 -*-
n,m = map(int,input().split())
mx = [[0]*n for _ in range(n)]
for _ in range(m):
    a,b = map(int,input().split())
    mx[a][a]+=1
    mx[b][b]+=1
    mx[a][b]-=1
    mx[b][a]-=1
for row in mx: print(*row)

"""info
Created on Tue Nov 16 08:20:55 2021
@author: Asus
http://cs101.openjudge.cn/practice/19943/
19943:图的拉普拉斯矩阵(matrix)
总时间限制: 1000ms 内存限制: 65536kB
描述
在图论中，度数矩阵是一个对角矩阵 ，其中包含的信息为的每一个顶点的度数，也就是说，每个顶点相邻的边数。邻接矩阵是图的一种常用存储方式。如果一个图一共有编号为0,1,2，…n-1的n个节点，那么邻接矩阵A的大小为n*n，对其中任一元素Aij，如果节点i，j直接有边，那么Aij=1；否则Aij=0。
将度数矩阵与邻接矩阵逐位相减，可以求得图的拉普拉斯矩阵。具体可见下图示意。
现给出一个图中的所有边的信息，需要你输出该图的拉普拉斯矩阵。
输入
第一行2个整数，代表该图的顶点数n和边数m。
接下m行，每行为空格分隔的2个整数a和b，代表顶点a和顶点b之间有一条无向边相连，a和b均为大小范围在0到n-1之间的整数。输入保证每条无向边仅出现一次（如1 2和2 1是同一条边，并不会在数据中同时出现）。
输出
共n行，每行为以空格分隔的n个整数，代表该图的拉普拉斯矩阵。
样例输入
4 5
2 1
1 3
2 3
0 1
0 2
样例输出
2 -1 -1 0
-1 3 -1 -1
-1 -1 3 -1
0 -1 -1 2
"""